/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/js-logger/src/logger.js
var require_logger = __commonJS({
  "node_modules/js-logger/src/logger.js"(exports, module2) {
    (function(global) {
      "use strict";
      var Logger7 = {};
      Logger7.VERSION = "1.6.1";
      var logHandler;
      var contextualLoggersByNameMap = {};
      var bind = function(scope, func) {
        return function() {
          return func.apply(scope, arguments);
        };
      };
      var merge = function() {
        var args = arguments, target = args[0], key, i;
        for (i = 1; i < args.length; i++) {
          for (key in args[i]) {
            if (!(key in target) && args[i].hasOwnProperty(key)) {
              target[key] = args[i][key];
            }
          }
        }
        return target;
      };
      var defineLogLevel = function(value, name) {
        return { value, name };
      };
      Logger7.TRACE = defineLogLevel(1, "TRACE");
      Logger7.DEBUG = defineLogLevel(2, "DEBUG");
      Logger7.INFO = defineLogLevel(3, "INFO");
      Logger7.TIME = defineLogLevel(4, "TIME");
      Logger7.WARN = defineLogLevel(5, "WARN");
      Logger7.ERROR = defineLogLevel(8, "ERROR");
      Logger7.OFF = defineLogLevel(99, "OFF");
      var ContextualLogger = function(defaultContext) {
        this.context = defaultContext;
        this.setLevel(defaultContext.filterLevel);
        this.log = this.info;
      };
      ContextualLogger.prototype = {
        // Changes the current logging level for the logging instance.
        setLevel: function(newLevel) {
          if (newLevel && "value" in newLevel) {
            this.context.filterLevel = newLevel;
          }
        },
        // Gets the current logging level for the logging instance
        getLevel: function() {
          return this.context.filterLevel;
        },
        // Is the logger configured to output messages at the supplied level?
        enabledFor: function(lvl) {
          var filterLevel = this.context.filterLevel;
          return lvl.value >= filterLevel.value;
        },
        trace: function() {
          this.invoke(Logger7.TRACE, arguments);
        },
        debug: function() {
          this.invoke(Logger7.DEBUG, arguments);
        },
        info: function() {
          this.invoke(Logger7.INFO, arguments);
        },
        warn: function() {
          this.invoke(Logger7.WARN, arguments);
        },
        error: function() {
          this.invoke(Logger7.ERROR, arguments);
        },
        time: function(label) {
          if (typeof label === "string" && label.length > 0) {
            this.invoke(Logger7.TIME, [label, "start"]);
          }
        },
        timeEnd: function(label) {
          if (typeof label === "string" && label.length > 0) {
            this.invoke(Logger7.TIME, [label, "end"]);
          }
        },
        // Invokes the logger callback if it's not being filtered.
        invoke: function(level, msgArgs) {
          if (logHandler && this.enabledFor(level)) {
            logHandler(msgArgs, merge({ level }, this.context));
          }
        }
      };
      var globalLogger = new ContextualLogger({ filterLevel: Logger7.OFF });
      (function() {
        var L = Logger7;
        L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
        L.trace = bind(globalLogger, globalLogger.trace);
        L.debug = bind(globalLogger, globalLogger.debug);
        L.time = bind(globalLogger, globalLogger.time);
        L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
        L.info = bind(globalLogger, globalLogger.info);
        L.warn = bind(globalLogger, globalLogger.warn);
        L.error = bind(globalLogger, globalLogger.error);
        L.log = L.info;
      })();
      Logger7.setHandler = function(func) {
        logHandler = func;
      };
      Logger7.setLevel = function(level) {
        globalLogger.setLevel(level);
        for (var key in contextualLoggersByNameMap) {
          if (contextualLoggersByNameMap.hasOwnProperty(key)) {
            contextualLoggersByNameMap[key].setLevel(level);
          }
        }
      };
      Logger7.getLevel = function() {
        return globalLogger.getLevel();
      };
      Logger7.get = function(name) {
        return contextualLoggersByNameMap[name] || (contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name }, globalLogger.context)));
      };
      Logger7.createDefaultHandler = function(options) {
        options = options || {};
        options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
          if (context.name) {
            messages.unshift("[" + context.name + "]");
          }
        };
        var timerStartTimeByLabelMap = {};
        var invokeConsoleMethod = function(hdlr, messages) {
          Function.prototype.apply.call(hdlr, console, messages);
        };
        if (typeof console === "undefined") {
          return function() {
          };
        }
        return function(messages, context) {
          messages = Array.prototype.slice.call(messages);
          var hdlr = console.log;
          var timerLabel;
          if (context.level === Logger7.TIME) {
            timerLabel = (context.name ? "[" + context.name + "] " : "") + messages[0];
            if (messages[1] === "start") {
              if (console.time) {
                console.time(timerLabel);
              } else {
                timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
              }
            } else {
              if (console.timeEnd) {
                console.timeEnd(timerLabel);
              } else {
                invokeConsoleMethod(hdlr, [timerLabel + ": " + (new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + "ms"]);
              }
            }
          } else {
            if (context.level === Logger7.WARN && console.warn) {
              hdlr = console.warn;
            } else if (context.level === Logger7.ERROR && console.error) {
              hdlr = console.error;
            } else if (context.level === Logger7.INFO && console.info) {
              hdlr = console.info;
            } else if (context.level === Logger7.DEBUG && console.debug) {
              hdlr = console.debug;
            } else if (context.level === Logger7.TRACE && console.trace) {
              hdlr = console.trace;
            }
            options.formatter(messages, context);
            invokeConsoleMethod(hdlr, messages);
          }
        };
      };
      Logger7.useDefaults = function(options) {
        Logger7.setLevel(options && options.defaultLevel || Logger7.DEBUG);
        Logger7.setHandler(Logger7.createDefaultHandler(options));
      };
      Logger7.setDefaults = Logger7.useDefaults;
      if (typeof define === "function" && define.amd) {
        define(Logger7);
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = Logger7;
      } else {
        Logger7._prevLogger = global.Logger;
        Logger7.noConflict = function() {
          global.Logger = Logger7._prevLogger;
          return Logger7;
        };
        global.Logger = Logger7;
      }
    })(exports);
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ViewCountPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// src/obsidian/view-count-settings-tab.ts
var import_obsidian = require("obsidian");

// src/logger/constants.ts
var LOG_LEVEL_OFF = "off";
var LOG_LEVEL_ERROR = "error";
var LOG_LEVEL_WARN = "warn";
var LOG_LEVEL_INFO = "info";
var LOG_LEVEL_DEBUG = "debug";
var LOG_LEVEL_TRACE = "trace";

// src/obsidian/view-count-settings-tab.ts
var import_js_logger2 = __toESM(require_logger());

// src/logger/index.ts
var import_js_logger = __toESM(require_logger());
var stringToLogLevel = (value) => {
  switch (value) {
    case LOG_LEVEL_OFF:
      return import_js_logger.default.OFF;
    case LOG_LEVEL_ERROR:
      return import_js_logger.default.ERROR;
    case LOG_LEVEL_WARN:
      return import_js_logger.default.WARN;
    case LOG_LEVEL_INFO:
      return import_js_logger.default.INFO;
    case LOG_LEVEL_DEBUG:
      return import_js_logger.default.DEBUG;
    case LOG_LEVEL_TRACE:
      return import_js_logger.default.TRACE;
    default:
      throw new Error(`Unhandled log level: ${value}`);
  }
};
var formatMessageForLogger = (...args) => {
  const data = args[1];
  return { message: args[0], data };
};

// src/obsidian/view-count-settings-tab.ts
var ViewCountSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const storageTypeDesc = new DocumentFragment();
    storageTypeDesc.createDiv({
      text: "If property is selected, each note will have their view count stored in a property in their frontmatter. If file is selected, the view count for all notes will be stored in a file in the Obsidian config directory."
    });
    storageTypeDesc.createEl("br");
    storageTypeDesc.createDiv({
      text: "Please restart Obsidian after changing this setting.",
      cls: "view-count-text--emphasize"
    });
    new import_obsidian.Setting(containerEl).setName("Storage type").setDesc(storageTypeDesc).addDropdown((component) => component.addOptions({
      "property": "Property",
      "file": "File"
    }).setValue(this.plugin.settings.storageType).onChange(async (value) => {
      this.plugin.settings.storageType = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Increment once a day").setDesc("If enabled a file view count will only be incremented once a day. Otherwise, the file view count will be incremented every time it is opened.").addToggle((component) => component.setValue(this.plugin.settings.incrementOnceADay).onChange(async (value) => {
      this.plugin.settings.incrementOnceADay = value;
      await this.plugin.saveSettings();
    }));
    const viewCountDesc = new DocumentFragment();
    viewCountDesc.createDiv({
      text: "The name of the property that the view count will be stored in. This is only used if the storage type is set to property."
    });
    viewCountDesc.createEl("br");
    viewCountDesc.createDiv({
      text: "Please rename the existing property before updating this setting. You can use the rename option in the All Properties view in the sidebar to do this.",
      cls: "view-count-text--emphasize"
    });
    new import_obsidian.Setting(containerEl).setName("View count property name").setDesc(viewCountDesc).setDisabled(this.plugin.settings.storageType !== "property").addText((text) => text.setValue(this.plugin.settings.viewCountPropertyName).onChange(async (value) => {
      this.plugin.settings.viewCountPropertyName = value;
      await this.plugin.saveSettings();
    }));
    const viewDateDesc = new DocumentFragment();
    viewDateDesc.createDiv({
      text: "The name of the property that the last view date will be stored in. This is only used if increment once a day is enabled."
    });
    viewDateDesc.createEl("br");
    viewDateDesc.createDiv({
      text: "Please rename the existing property before updating this setting. You can use the rename option in the All Properties view in the sidebar to do this.",
      cls: "view-count-text--emphasize"
    });
    new import_obsidian.Setting(containerEl).setName("View date property name").setDesc(viewDateDesc).setDisabled(this.plugin.settings.storageType !== "property" || !this.plugin.settings.incrementOnceADay).addText((text) => text.setValue(this.plugin.settings.lastViewDatePropertyName).onChange(async (value) => {
      this.plugin.settings.lastViewDatePropertyName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Debugging").setHeading();
    new import_obsidian.Setting(containerEl).setName("Log level").setDesc(
      "Sets the log level. Please use trace to see all log messages."
    ).addDropdown((cb) => {
      cb.addOptions({
        [LOG_LEVEL_OFF]: "Off",
        [LOG_LEVEL_ERROR]: "Error",
        [LOG_LEVEL_WARN]: "Warn",
        [LOG_LEVEL_INFO]: "Info",
        [LOG_LEVEL_DEBUG]: "Debug",
        [LOG_LEVEL_TRACE]: "Trace"
      });
      cb.setValue(this.plugin.settings.logLevel).onChange(
        async (value) => {
          this.plugin.settings.logLevel = value;
          await this.plugin.saveSettings();
          import_js_logger2.default.setLevel(stringToLogLevel(value));
        }
      );
    });
  }
};
var view_count_settings_tab_default = ViewCountSettingsTab;

// src/storage/file-storage.ts
var import_obsidian3 = require("obsidian");

// src/storage/utils.ts
var import_obsidian2 = require("obsidian");
var stringifyEntries = (entries) => {
  return JSON.stringify({
    items: entries
  }, null, 2);
};
var parseEntries = (fileData) => {
  const json = JSON.parse(fileData);
  if (!json.items)
    return [];
  return json.items;
};
var getFilePath = (app) => {
  const VIEW_COUNT_FILE = "view-count.json";
  return (0, import_obsidian2.normalizePath)(app.vault.configDir + "/" + VIEW_COUNT_FILE);
};
var setPropertyType = async (app, name, value) => {
  await app.metadataTypeManager.setType(name, value);
};
var getPropertyType = async (app, name) => {
  return app.metadataTypeManager.getAssignedType(name);
};

// src/event/event-manager.ts
var EventManager = class {
  constructor() {
    this.eventListeners = {};
  }
  // Ensures only one instance is created
  static getInstance() {
    if (!EventManager.instance) {
      EventManager.instance = new EventManager();
    }
    return EventManager.instance;
  }
  // Method to add an event listener
  on(eventName, callback) {
    if (!this.eventListeners[eventName]) {
      this.eventListeners[eventName] = [];
    }
    this.eventListeners[eventName].push(callback);
  }
  // Method to remove an event listener
  off(eventName, callbackToRemove) {
    if (!this.eventListeners[eventName]) {
      return;
    }
    this.eventListeners[eventName] = this.eventListeners[eventName].filter(
      (callback) => callback !== callbackToRemove
    );
  }
  // Method to trigger all callbacks associated with an event
  emit(eventName, ...data) {
    if (!this.eventListeners[eventName]) {
      return;
    }
    this.eventListeners[eventName].forEach((callback) => {
      callback(...data);
    });
  }
};

// src/storage/view-count-storage.ts
var ViewCountStorage = class {
  constructor() {
    this.entries = [];
  }
  getEntries() {
    return this.entries;
  }
  refresh() {
    EventManager.getInstance().emit("refresh-item-view");
  }
};

// src/storage/file-storage.ts
var import_js_logger3 = __toESM(require_logger());
var FileStorage = class extends ViewCountStorage {
  constructor(app) {
    super();
    this.app = app;
  }
  async load() {
    import_js_logger3.default.trace("FileStorage load");
    const path = getFilePath(this.app);
    const exists = await this.app.vault.adapter.exists(path);
    if (!exists) {
      const data = stringifyEntries([]);
      try {
        import_js_logger3.default.debug("Creating file cache");
        await this.app.vault.create(path, data);
      } catch (err) {
        console.error("Error creating file cache: ", err.message);
        new import_obsidian3.Notice("View Count: error loading view count");
      }
      return;
    }
    try {
      const result = await this.app.vault.adapter.read(path);
      this.entries = parseEntries(result);
      import_js_logger3.default.debug("Loaded entries", { entries: this.entries });
      this.refresh();
    } catch (err) {
      console.error("Error loading file cache: ", err.message);
      new import_obsidian3.Notice("View Count: error loading cache");
    }
  }
  async save(app) {
    import_js_logger3.default.trace("FileStorage save");
    try {
      const path = getFilePath(app);
      const data = stringifyEntries(this.entries);
      await app.vault.adapter.write(path, data);
    } catch (err) {
      console.error("Error saving file cache: ", err.message);
      new import_obsidian3.Notice("View Count: error saving file cache");
    }
  }
  async incrementViewCount(file) {
    import_js_logger3.default.trace("FileStorage incrementViewCount");
    import_js_logger3.default.debug("Incrementing view count for file", { path: file.path });
    const entry = this.entries.find((entry2) => entry2.path === file.path);
    if (entry) {
      import_js_logger3.default.debug("Incrementing existing entry");
      this.entries = this.entries.map((entry2) => {
        if (entry2.path === file.path) {
          return {
            ...entry2,
            viewCount: entry2.viewCount + 1,
            lastViewMillis: Date.now()
          };
        }
        return entry2;
      });
    } else {
      import_js_logger3.default.debug("Adding new entry");
      this.entries = [...this.entries, {
        path: file.path,
        viewCount: 1,
        lastViewMillis: Date.now()
      }];
    }
    await this.save(this.app);
    this.refresh();
  }
  async getLastViewTime(file) {
    var _a, _b;
    return (_b = (_a = this.entries.find((entry) => entry.path === file.path)) == null ? void 0 : _a.lastViewMillis) != null ? _b : 0;
  }
  async getViewCount(file) {
    var _a, _b;
    return (_b = (_a = this.entries.find((entry) => entry.path === file.path)) == null ? void 0 : _a.viewCount) != null ? _b : 0;
  }
  async renameEntry(newPath, oldPath) {
    import_js_logger3.default.trace("FileStorage renameEntry");
    import_js_logger3.default.debug("Renaming entry", { oldPath, newPath });
    this.entries = this.entries.map((entry) => {
      if (entry.path === oldPath) {
        entry.path = newPath;
      }
      return entry;
    });
    await this.save(this.app);
    this.refresh();
  }
  async deleteEntry(file) {
    import_js_logger3.default.trace("FileStorage deleteEntry");
    import_js_logger3.default.debug("Deleting entry", { path: file.path });
    this.entries = this.entries.filter((entry) => entry.path !== file.path);
    await this.save(this.app);
    this.refresh();
  }
};

// src/utils/time-utils.ts
var import_obsidian4 = require("obsidian");
var unixTimeMillisToDate = (unixTimeMillis) => {
  const unixTimeSeconds = unixTimeMillis / 1e3;
  const normalTimestamp = import_obsidian4.moment.unix(unixTimeSeconds);
  const formattedTimestamp = normalTimestamp.format("YYYY-MM-DD");
  return formattedTimestamp;
};
var dateToUnixTimeMillis = (date) => {
  const normalTimestamp = (0, import_obsidian4.moment)(date);
  const unixTimeMillis = normalTimestamp.valueOf();
  return unixTimeMillis;
};
var startTodayMillis = () => {
  return (0, import_obsidian4.moment)().startOf("day").valueOf();
};

// src/storage/property-storage.ts
var import_js_logger4 = __toESM(require_logger());
var PropertyStorage = class extends ViewCountStorage {
  constructor(app, settings) {
    super();
    this.app = app;
    this.settings = settings;
  }
  async load() {
    var _a, _b;
    import_js_logger4.default.trace("PropertyStorage load");
    const { viewCountPropertyName, lastViewDatePropertyName } = this.settings;
    const markdownFiles = this.app.vault.getMarkdownFiles();
    for (const file of markdownFiles) {
      const frontmatter = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
      const date = (_b = frontmatter == null ? void 0 : frontmatter[lastViewDatePropertyName]) != null ? _b : "";
      const timeMillis = dateToUnixTimeMillis(date);
      if ((frontmatter == null ? void 0 : frontmatter[viewCountPropertyName]) !== void 0) {
        this.entries.push({
          viewCount: frontmatter == null ? void 0 : frontmatter[viewCountPropertyName],
          lastViewMillis: timeMillis,
          path: file.path
        });
      }
    }
    import_js_logger4.default.debug("Loaded entries", { entries: this.entries });
    this.refresh();
  }
  async incrementViewCount(file) {
    import_js_logger4.default.trace("PropertyStorage incrementViewCount");
    import_js_logger4.default.debug("Incrementing view count for file", { path: file.path });
    const { viewCountPropertyName, incrementOnceADay, lastViewDatePropertyName } = this.settings;
    const entry = this.entries.find((entry2) => entry2.path === file.path);
    if (entry) {
      this.entries = this.entries.map((entry2) => {
        if (entry2.path === file.path) {
          return {
            ...entry2,
            viewCount: entry2.viewCount + 1,
            lastViewMillis: Date.now()
          };
        }
        return entry2;
      });
    } else {
      this.entries = [...this.entries, {
        path: file.path,
        viewCount: 1,
        lastViewMillis: Date.now()
      }];
    }
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      if (incrementOnceADay) {
        import_js_logger4.default.debug("Updating view date");
        const date = unixTimeMillisToDate(Date.now());
        frontmatter[lastViewDatePropertyName] = date;
      }
      if (!frontmatter[viewCountPropertyName]) {
        import_js_logger4.default.debug("Setting view count to 1");
        frontmatter[viewCountPropertyName] = 1;
      } else {
        import_js_logger4.default.debug("Incrementing view count");
        frontmatter[viewCountPropertyName]++;
      }
    });
    this.refresh();
  }
  async getViewCount(file) {
    const { viewCountPropertyName } = this.settings;
    let viewCount = 0;
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      var _a;
      viewCount = (_a = frontmatter[viewCountPropertyName]) != null ? _a : 0;
    });
    return viewCount;
  }
  async getLastViewTime(file) {
    const { lastViewDatePropertyName } = this.settings;
    let lastViewDate = "";
    await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
      var _a;
      lastViewDate = (_a = frontmatter[lastViewDatePropertyName]) != null ? _a : "";
    });
    const timeMillis = dateToUnixTimeMillis(lastViewDate);
    return timeMillis;
  }
  async renameEntry(newPath, oldPath) {
    import_js_logger4.default.trace("PropertyStorage renameEntry");
    import_js_logger4.default.debug("Renaming entry", { oldPath, newPath });
    this.entries = this.entries.map((entry) => {
      if (entry.path === oldPath) {
        entry.path = newPath;
      }
      return entry;
    });
    this.refresh();
  }
  async deleteEntry(file) {
    import_js_logger4.default.trace("PropertyStorage deleteEntry");
    import_js_logger4.default.debug("Deleting entry", { path: file.path });
    this.entries = this.entries.filter((entry) => entry.path !== file.path);
    this.refresh();
  }
};

// src/obsidian/view-count-item-view.ts
var import_obsidian5 = require("obsidian");

// src/constants.ts
var VIEW_COUNT_ITEM_VIEW = "view-count";

// src/obsidian/view-count-item-view.ts
var ViewCountItemView = class extends import_obsidian5.ItemView {
  constructor(leaf, app, storage) {
    super(leaf);
    this.handleRefreshEvent = () => {
      this.onClose();
      this.onOpen();
    };
    this.app = app;
    this.storage = storage;
  }
  getViewType() {
    return VIEW_COUNT_ITEM_VIEW;
  }
  getDisplayText() {
    return "View count";
  }
  getIcon() {
    return "eye";
  }
  async onOpen() {
    const { contentEl } = this;
    let sortedEntries = [...this.storage.getEntries()];
    sortedEntries.sort((a, b) => b.viewCount - a.viewCount);
    sortedEntries = sortedEntries.slice(0, 20);
    EventManager.getInstance().on("refresh-item-view", this.handleRefreshEvent);
    if (sortedEntries.length === 0) {
      contentEl.createDiv({ cls: "pane-empty", text: "No notes with view count found." });
      return;
    }
    for (const entry of sortedEntries) {
      const file = this.app.vault.getFileByPath(entry.path);
      if (!file) {
        continue;
      }
      const containerEl = contentEl.createDiv({ cls: "tree-item" });
      const itemDiv = containerEl.createDiv({ cls: "tree-item-self is-clickable" });
      const innerDiv = itemDiv.createDiv({ cls: "tree-item-inner" });
      const displayName = file.extension == "md" ? file.basename : file.name;
      innerDiv.createDiv({ cls: "tree-item-inner-text", text: displayName });
      const flairOuterDiv = itemDiv.createDiv({ cls: "tree-item-flair-outer" });
      flairOuterDiv.createDiv({ cls: "tree-item-flair", text: entry.viewCount.toString() });
      itemDiv.addEventListener("click", () => {
        var _a;
        (_a = this.app.workspace.getLeaf(false)) == null ? void 0 : _a.setViewState({
          type: file.extension == "canvas" ? "canvas" : "markdown",
          active: true,
          state: {
            file: entry.path
          }
        });
      });
    }
  }
  async onClose() {
    const { contentEl } = this;
    contentEl.empty();
    EventManager.getInstance().off("refresh-item-view", this.handleRefreshEvent);
  }
};

// src/migrate/migrate-0.5.0.ts
var import_js_logger5 = __toESM(require_logger());
var Migrate_050 = class {
  constructor(plugin, app, settings) {
    this.plugin = plugin;
    this.app = app;
    this.settings = settings;
  }
  async migrate() {
    await this.migrateViewTimeName();
    await this.migrateViewTimeFromNumberToDate();
  }
  /**
   * This will update the property name to "view-date" if it's not already
   */
  async migrateViewTimeName() {
    import_js_logger5.default.trace("Migrate_050 migrateViewTimeName");
    const { lastViewTimePropertyName, lastViewDatePropertyName } = this.settings;
    if (lastViewTimePropertyName !== "last-view-time") {
      import_js_logger5.default.debug("Updating lastViewDatePropertyName to lastViewTimePropertyName value", { lastViewTimePropertyName });
      this.settings.lastViewDatePropertyName = lastViewTimePropertyName;
      await this.plugin.saveSettings();
    } else {
      const markdownFiles = this.app.vault.getMarkdownFiles();
      for (const file of markdownFiles) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          if (!frontmatter[lastViewTimePropertyName])
            return;
          import_js_logger5.default.debug("Renaming last-view-time property name to view-date", { path: file.path });
          frontmatter[lastViewDatePropertyName] = frontmatter[lastViewTimePropertyName];
          delete frontmatter[lastViewTimePropertyName];
        });
      }
    }
  }
  /**
   * This will update the property type to date if it's not already
   */
  async migrateViewTimeFromNumberToDate() {
    import_js_logger5.default.trace("Migrate_050 migrateViewTimeFromNumberToDate");
    const { lastViewDatePropertyName } = this.settings;
    const type = await getPropertyType(this.app, lastViewDatePropertyName);
    import_js_logger5.default.debug("lastViewDatePropertyName type", { type });
    if (type != "date") {
      import_js_logger5.default.debug("Property type is not date");
      const markdownFiles = this.app.vault.getMarkdownFiles();
      for (const file of markdownFiles) {
        await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
          if (!frontmatter[lastViewDatePropertyName])
            return;
          if (typeof frontmatter[lastViewDatePropertyName] === "number") {
            import_js_logger5.default.debug("Converting lastViewDatePropertyName value to date", { path: file.path });
            const date = unixTimeMillisToDate(frontmatter[lastViewDatePropertyName]);
            frontmatter[lastViewDatePropertyName] = date;
          }
        });
      }
      import_js_logger5.default.debug("Setting lastViewDatePropertyName type to date");
      await setPropertyType(this.app, lastViewDatePropertyName, "date");
    }
  }
};

// src/main.ts
var import_js_logger6 = __toESM(require_logger());
var DEFAULT_SETTINGS = {
  incrementOnceADay: true,
  storageType: "property",
  viewCountPropertyName: "view-count",
  lastViewDatePropertyName: "view-date",
  lastViewTimePropertyName: "last-view-time",
  //TODO remove this after a few releases. 0.4.1 and prior
  pluginVersion: "",
  logLevel: LOG_LEVEL_OFF
};
var ViewCountPlugin = class extends import_obsidian6.Plugin {
  async onload() {
    await this.loadSettings();
    import_js_logger6.default.useDefaults();
    import_js_logger6.default.setHandler(function(messages) {
      const { message, data } = formatMessageForLogger(...messages);
      console.log(message);
      if (data) {
        console.log(data);
      }
    });
    const logLevel = stringToLogLevel(this.settings.logLevel);
    import_js_logger6.default.setLevel(logLevel);
    if (this.settings.storageType === "file") {
      this.storage = new FileStorage(this.app);
    } else if (this.settings.storageType === "property") {
      this.storage = new PropertyStorage(this.app, this.settings);
    }
    this.registerView(
      VIEW_COUNT_ITEM_VIEW,
      (leaf) => new ViewCountItemView(leaf, this.app, this.storage)
    );
    this.addSettingTab(new view_count_settings_tab_default(this.app, this));
    this.app.workspace.onLayoutReady(async () => {
      var _a;
      if (this.settings.pluginVersion === "") {
        await new Migrate_050(this, this.app, this.settings).migrate();
      }
      if (this.settings.pluginVersion !== this.manifest.version) {
        this.settings.pluginVersion = this.manifest.version;
        await this.saveSettings();
      }
      await this.storage.load();
      if (this.settings.storageType === "file") {
        await this.registerFileStorageEvents();
      } else if (this.settings.storageType === "property") {
        await this.registerPropertyStorageEvents();
      }
      const leaves = this.app.workspace.getLeavesOfType(VIEW_COUNT_ITEM_VIEW);
      if (leaves.length === 0) {
        (_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
          type: VIEW_COUNT_ITEM_VIEW,
          active: false
        });
      }
    });
  }
  async registerPropertyStorageEvents() {
    this.registerEvent(this.app.workspace.on("file-open", async (file) => {
      if (file === null)
        return;
      if (file.extension !== "md")
        return;
      const incrementOnceADay = this.settings.incrementOnceADay;
      if (incrementOnceADay) {
        import_js_logger6.default.debug("Increment once a day is enabled. Checking if view count should be incremented.");
        const lastViewMillis = await this.storage.getLastViewTime(file);
        const todayMillis = startTodayMillis();
        if (lastViewMillis >= todayMillis) {
          import_js_logger6.default.debug("View count already incremented today", { path: file.path, lastViewMillis, todayMillis });
          return;
        }
      }
      await this.storage.incrementViewCount(file);
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian6.TFile) {
        await this.storage.renameEntry(file.path, oldPath);
      }
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      if (file instanceof import_obsidian6.TFile) {
        this.storage.deleteEntry(file);
      }
    }));
  }
  async registerFileStorageEvents() {
    this.registerEvent(this.app.workspace.on("file-open", async (file) => {
      if (file === null)
        return;
      const incrementOnceADay = this.settings.incrementOnceADay;
      if (incrementOnceADay) {
        import_js_logger6.default.debug("Increment once a day is enabled. Checking if view count should be incremented.");
        const lastViewMillis = await this.storage.getLastViewTime(file);
        const todayMillis = startTodayMillis();
        if (lastViewMillis < todayMillis) {
          import_js_logger6.default.debug("View count not incremented today. Incrementing view count.", { path: file.path, lastViewMillis, todayMillis });
          await this.storage.incrementViewCount(file);
        } else {
          import_js_logger6.default.debug("View count already incremented today", { path: file.path, lastViewMillis, todayMillis });
        }
      } else {
        await this.storage.incrementViewCount(file);
      }
      if (!this.viewCountStatusBarItem) {
        this.viewCountStatusBarItem = this.addStatusBarItem();
      }
      const viewCount = await this.storage.getViewCount(file);
      const viewName = viewCount === 1 ? "view" : "views";
      this.viewCountStatusBarItem.setText(`${viewCount} ${viewName}`);
    }));
    this.registerEvent(this.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian6.TFile) {
        await this.storage.renameEntry(file.path, oldPath);
      }
    }));
    this.registerEvent(this.app.vault.on("delete", async (file) => {
      if (file instanceof import_obsidian6.TFile) {
        this.storage.deleteEntry(file);
      }
    }));
  }
  onunload() {
    var _a;
    (_a = this.viewCountStatusBarItem) == null ? void 0 : _a.remove();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

js-logger/src/logger.js:
  (*!
   * js-logger - http://github.com/jonnyreeves/js-logger
   * Jonny Reeves, http://jonnyreeves.co.uk/
   * js-logger may be freely distributed under the MIT license.
   *)
*/
